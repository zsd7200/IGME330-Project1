<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<!-- https://stackoverflow.com/questions/18301745/how-to-set-up-a-favicon -->
	<link rel="icon" type="image/png" href="media/favicon.png" sizes="16x16">

	
	<title>Dragon Ball Audio VisualiZer</title>
	
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.0/css/bootstrap.min.css" integrity="sha384-PDle/QlgIONtM1aqA2Qemk5gPOE7wFq8+Em+G/hmo5Iq0CCmYZLv3fVRDJ4MMwEA" crossorigin="anonymous">

	
	<style>
		body{ margin: 8px; }
	
		#pause { 
			position: absolute;
			z-index: 2;
			left: 575px;
			top: 25px;
			transform: scaleX(-1); 
		}
		
		#play {
			position: absolute;
			z-index: 2;
			left: 25px;
			top: 25px;
		}
	</style>

	<script>
	
	"use strict";
	window.onload = init;
	let canvas, ctx, play, pause, audio, state, fighter, enemy, beamPos, analyserNode, ballRadius, maxBarHeight, stars, gainNode, numBalls;
	let drawnBalls = [];
	let ballsToDraw = [];
	let ballLoc = [];
	let ballCenters = [];
	const BEAM_MIDDLE_COLOR = "#f3f3f3";
	const BEAM_HEIGHT = 30;
	
	const BAR_WIDTH = 5;
	const PADDING = 5;
	
	const CANVAS_HEIGHT = 600;
	const CANVAS_WIDTH = 700;
	
	
	// dictionary of beam colors based on fighter name
	// beamColors[fighter][0] = darkest color	(first)
	// beamColors[fighter][1] = mid	color		(second)
	// beamColors[fighter][2] = lightest color	(third)
	// then BEAM_MIDDLE_COLOR
	// beamColors[fighter][3] = beam endcap color
	
	const beamColors = {
		"goku" : ["#009aa4", "#00cedb", "#00f0ff", "blue"],
		"vegeta" : ["#9e00a0", "#d100d4", "#fc00ff", "purple"],
		"teenGohan" : ["#f8c518", "#f0e030", "#f8f878", "yellow"],
		"futureTrunks" : ["#f8c518", "#f0e030", "#f8f878", "yellow"],
		"android18" : ["#f8c518", "#f0e030", "#f8f878", "yellow"],
		"cell" : ["#009aa4", "#00cedb", "#00f0ff", "blue"],
		"majinbuu" : ["#9e00a0", "#d100d4", "#fc00ff", "purple"],
		"frieza" : ["#9e00a0", "#d100d4", "#fc00ff", "purple"]				
	};
	
	function init()
	{
		canvas = document.querySelector("canvas");
		ctx = canvas.getContext("2d");
		const NUM_SAMPLES = 128;
		numBalls = 1;
		
		//Getting elements from the DOM
		play = document.querySelector("#play"); 
		pause = document.querySelector("#pause");
		audio = document.querySelector("#audio");
		state = play.src.substr(-8).substr(0, 4); // result will be either Idle or Play
		
		// setup sliders and labels
		ballRadius = 150;
		stars = random(1, 7);
		document.querySelector("#radiusLabel").innerHTML = ballRadius;
		
		// fill up ballstodraw and drawnballs arrays
		ballsToDraw.push(stars)
		
		// fill array
		for (let i = 0; i < 6; i++)
			ballsToDraw.push(random(1,7, ballsToDraw));
			
		// splice array to remove stars from ballsToDraw array
		ballsToDraw = ballsToDraw.splice(1, 6);
		
		// initialize beamPos with values from CSS
		beamPos = setBeamPos(getComputedStyle(play).left, getComputedStyle(play).top);
		
		// draw big ball in center of canvas
		drawBall(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, ballRadius, stars);
		ballCenters.push([CANVAS_WIDTH/2, CANVAS_HEIGHT/2]);
		updateBallLoc();
		
		// set default fighter and enemy to Goku/Frieza
		fighter = "goku";
		enemy = "frieza";
		ctx.fillStyle = beamColors[fighter];
		
		let audioCtx = new (window.AudioContext || window.webkitAudioContext); // to support Safari and mobile
		let sourceNode = audioCtx.createMediaElementSource(audio); 
		analyserNode = audioCtx.createAnalyser();
		analyserNode.fftSize = NUM_SAMPLES;
		gainNode = audioCtx.createGain();
		gainNode.gain.value = 1;
		sourceNode.connect(gainNode);
		gainNode.connect(analyserNode);
		analyserNode.connect(audioCtx.destination);

		document.querySelector("#volumeLabel").innerHTML = gainNode.gain.value;

		// Starting the play music when the play button is pressed, and setting the state to "Play"
		play.onclick = function(e) {
			audioCtx.resume(); // needed for chrome to play music
			audio.play();
			state = "Play";
			
			// this needs to be reset in case the user restarts the same song
			pause.src = "media/" + enemy + "Idle.png";
			pause.style.zIndex = 2;
		};

		// Pausing the music when the pause button is pressed
		// State is not set to "idle" because this would look jarring, as the beam stays out
		pause.onclick = function(e) { audio.pause(); audioCtx.suspend(); };

		// attach musicChange script
		document.querySelector("#songSelector").onchange = musicChange;
		
		// handle changing of fighter/enemy
		document.querySelector("#playSelector").onchange = function(e){ fighter = e.target.value; };
		document.querySelector("#pauseSelector").onchange = function(e) { enemy = e.target.value; pause.src = "media/" + enemy + "Idle.png"; };
		
		// handle changing stars and radius based on sliders
		document.querySelector("#ballRad").oninput = function(e) { 
			ballRadius = parseInt(e.target.value, 10);
			document.querySelector("#radiusLabel").innerHTML = parseInt(e.target.value, 10);
			ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
			
			// updateBallLoc updates ballLoc array based on new ballRadius
			updateBallLoc();
			
			// draw initial ball
			drawBall(ballCenters[0][0], ballCenters[0][1], ballRadius, drawnBalls[0]);
			
			for(let i = 0; i < ballLoc.length; i++)
			{
					drawBall(ballLoc[i][0], ballLoc[i][1], ballRadius/2, drawnBalls[i+1]);
			}
		};

		document.querySelector("#volumeSlider").oninput = function(e) {
			gainNode.gain.value = e.target.value;
			document.querySelector("#volumeLabel").innerHTML = Math.round((e.target.value/2 * 100));
		}

		document.querySelector("#addBall").onclick = addBall;
		document.querySelector("#remBall").onclick = remBall;

		//Setting up full screen 
		document.querySelector("#fullscreenBut").onclick = _ =>{
				requestFullscreen(canvas);
			};

		// update for beam creation and animation
		update();
	}
	
	// poc addBall method
	function addBall()
	{	
		if (ballsToDraw.length > 0)
		{
			drawBall(ballLoc[numBalls - 1][0], ballLoc[numBalls - 1][1], ballRadius/2, ballsToDraw[ballsToDraw.length - 1]);
			ballCenters.push([CANVAS_WIDTH/2 + ballRadius * 1.75, CANVAS_HEIGHT/2]);
			ballsToDraw.pop();
			numBalls++;
		}
	}
	
	// todo: clearrect for only section of canvas
	// use ballCenters?
	// if we use ballCenters then we can clearrect based on center + radius and just clear that section
	// at least that's how I think it works
	// update: can't use ballCenters because of how that's being created, so I made a new ballLoc array
	function remBall()
	{
		
	}
	
	// helper function to update ballLoc array based on ballRadius
	function updateBallLoc()
	{
		ballLoc = [
			[CANVAS_WIDTH/2 + ballRadius * 1.75, CANVAS_HEIGHT/2],
			[CANVAS_WIDTH/2 - ballRadius * 1.75, CANVAS_HEIGHT/2],
			[CANVAS_WIDTH/2 + ballRadius * 1.25, CANVAS_HEIGHT/2 - ballRadius * 1.25],
			[CANVAS_WIDTH/2 - ballRadius * 1.25, CANVAS_HEIGHT/2 - ballRadius * 1.25],
			[CANVAS_WIDTH/2 + ballRadius * 1.25, CANVAS_HEIGHT/2 + ballRadius * 1.25],
			[CANVAS_WIDTH/2 - ballRadius * 1.25, CANVAS_HEIGHT/2 + ballRadius * 1.25]
		];
	}
	
	// handle setting beam position based on left and top from #play object's CSS values
	function setBeamPos(left = 25, top = 25)
	{
		// beamPos[fighter][0] = x
		// beamPos[fighter][1] = y
		// width is changed based on time left in song
		// height is BEAM_HEIGHT
		let tempPos = {
			"goku" : [60 + parseInt(left, 10), 30 + parseInt(top, 10)],
			"vegeta" : [60 + parseInt(left, 10), 20 + parseInt(top, 10)],
			"teenGohan" : [55 + parseInt(left, 10), 35 + parseInt(top, 10)],
			"futureTrunks" : [60 + parseInt(left, 10), 11 + parseInt(top, 10)],
			"android18" : [70 + parseInt(left, 10), 20 + parseInt(top, 10)],
			"cell" : [67 + parseInt(left, 10), 22 + parseInt(top, 10)],
			"majinbuu" : [68 + parseInt(left, 10), 25 + parseInt(top, 10)],
			"frieza" : [70 + parseInt(left, 10), 20 + parseInt(top, 10)]				
		};
		
		return tempPos;
	}

	function requestFullscreen(element)
	{
		if (element.requestFullscreen) {
			  element.requestFullscreen();
			} else if (element.mozRequestFullscreen) {
			  element.mozRequestFullscreen();
			} else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
			  element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
			  element.webkitRequestFullscreen();
			}
	}
	
	// handles if music is changed from dropdown
	function musicChange(e)
	{
		// if music is currently playing, pause it
		if(state == "Play")
		{
			audio.pause();
			state = "Idle";
		}
		
		// if song is over, then the beamcap is out and the enemy is in it's "dmgd" state
		// return enemy to idle state and return the enemy to its proper z-index so it can be clicked
		if (audio.duration == audio.currentTime)
		{
			pause.src = "media/" + enemy + "Idle.png";
			pause.style.zIndex = 2;
		}
		
		// handle door.wav since it's not an mp3 lmao
		if (e.target.value != "door")
			audio.src = "media/" + e.target.value + ".mp3";
		else
			audio.src = "media/door.wav";
		
		// wipe canvas of beam
		ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
		
		// redraw ball
		drawBall(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, ballRadius, stars);
	}

	// used for creation of beam
	function update()
	{
		requestAnimationFrame(update);
		let data = new Uint8Array(analyserNode.frequencyBinCount); // OR analyserNode.fftSize/2
		//Showing frequency 
		analyserNode.getByteFrequencyData(data);
		//analyserNode.getByteTimeDomainData(data);
		
		// Changing the state of the sprite based on the playing status
		if(state == "Play")
		{
			let percent = audio.currentTime / audio.duration;
			play.src = "media/" + fighter + "Play.png";
			ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
			
			// draw darkest color first
			ctx.fillStyle = beamColors[fighter][0];
			ctx.fillRect(beamPos[fighter][0], beamPos[fighter][1], 525 * percent, BEAM_HEIGHT);
			
			// middle color second
			ctx.fillStyle = beamColors[fighter][1];
			ctx.fillRect(beamPos[fighter][0], beamPos[fighter][1] + 2, 525 * percent, BEAM_HEIGHT - 4);
			
			// light color third
			ctx.fillStyle = beamColors[fighter][2];
			ctx.fillRect(beamPos[fighter][0], beamPos[fighter][1] + 2.5, 525 * percent, BEAM_HEIGHT - 5);
			
			// finish with white/BEAM_MIDDLE_COLOR in center
			ctx.fillStyle = BEAM_MIDDLE_COLOR;
			ctx.fillRect(beamPos[fighter][0], beamPos[fighter][1] + 4.5, 525 * percent, BEAM_HEIGHT - 9);	
			
			for (let i = 0; i < 64; i++)
			{
				let percent = data[i] / 255;
				percent = percent < .07 ? .07 : percent;
				
				ctx.save();
				ctx.fillStyle = beamColors[fighter][0];
				ctx.translate(CANVAS_WIDTH/2, CANVAS_HEIGHT/2);		// behind 4* ball
				//ctx.translate(CANVAS_WIDTH/2, CANVAS_HEIGHT/2);		// dead center
				ctx.scale(1, -1);
				
				let rotationAmount = (Math.PI * 2) * ((i + 1) / 64);
				ctx.rotate(rotationAmount);
				ctx.translate(0, maxBarHeight / 1.1);
				ctx.fillRect(0, 0, BAR_WIDTH, maxBarHeight * percent);
				ctx.restore();

				
			}

			
			
			drawBall(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, ballRadius, stars);

			//Switching to waveform data
			analyserNode.getByteTimeDomainData(data);
			//Displaying the waveform as an innercircle to the ball, scalable to multiple balls
			///TODO: Figure out how to only display parts of the waveform, if we want multiple balls
			for(let i = 0; i < data.length; i++){
				for(let j = 0; j < numBalls *2; j+=2)
				{
					let percent2 = data[i] / 255;

					ctx.save();
					ctx.fillStyle = "rgba(100,100,100,.3)";
					ctx.beginPath();
					ctx.arc(ballCenters[j], ballCenters[j+1], ballRadius * percent2,0,  2*Math.PI, false);
					ctx.fill();
					ctx.closePath();
					ctx.restore();
				}
			}
		}
		else if (state == "Idle")
			play.src = "media/" + fighter + "Idle.png";
		
		// if song is over, change enemy state to "dmgd" and add beamcap
		if(audio.duration == audio.currentTime)
		{
			pause.src = "media/" + enemy + "Dmgd.png";
			let beamCap = new Image();
			beamCap.src = "media/" + beamColors[fighter][3] + "BeamCap.png";
			pause.style.zIndex = -1;
			ctx.drawImage(beamCap, 600, beamPos[fighter][1] - 13);
		}
	}
	
	// draw a star based on a single point
	function drawStar(cpX, cpY, lngt, fillStyle = "red")
	{
		// move Y so the user input is closer to center point
		cpY += lngt * .6;
		
		ctx.save();
		ctx.fillStyle = fillStyle;
		
		// start first tri
		ctx.beginPath();
		ctx.moveTo(cpX, cpY);
		ctx.lineTo(cpX, cpY - (lngt * 2));
		ctx.lineTo(cpX - lngt, cpY + (lngt * .7));
		ctx.closePath();
		ctx.fill();
		
		// second tri
		ctx.beginPath();
		ctx.moveTo(cpX, cpY);
		ctx.lineTo(cpX, cpY - (lngt * 2));
		ctx.lineTo(cpX + lngt, cpY + (lngt * .7));
		ctx.closePath();
		ctx.fill();
		
		// third and final tri
		ctx.beginPath();
		ctx.moveTo(cpX, cpY);
		ctx.lineTo(cpX - (lngt + (lngt/2)), cpY - lngt);
		ctx.lineTo(cpX + (lngt + (lngt/2)), cpY - lngt);
		ctx.closePath();
		ctx.fill();
		
		// fill in little remaining bit of transparency
		ctx.strokeStyle = fillStyle;
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(cpX, cpY);
		ctx.lineTo(cpX, cpY - (lngt * 2) + (lngt / 3.75));
		ctx.closePath();
		ctx.stroke();

		// restore original context values
		ctx.restore();
	}
	
	function drawBall(x, y, rad, stars = 4, maxBar = (rad * 1.1), lineWidth = (rad * .06))
	{
		maxBarHeight = maxBar;
		
		drawnBalls.push(stars);
	
		ctx.save();
		
		// set styles
		ctx.fillStyle = "yellow";
		ctx.strokeStyle = "black";
		ctx.lineWidth = lineWidth;
		
		// draw orb
		ctx.beginPath();
		ctx.arc(x, y, rad, 0, Math.PI * 2, false);
		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		
		// draw inner orb
		// https://stackoverflow.com/questions/5475755/how-to-draw-a-blurry-circle-on-html5-canvas
		let orangeGrad = ctx.createRadialGradient(x,y,0,x,y,rad);
		orangeGrad.addColorStop(0, "rgba(255, 165, 0, 1)");
		orangeGrad.addColorStop(0.8, "rgba(228, 192, 0, .9)");
		orangeGrad.addColorStop(1, "rgba(228, 192, 0, 0)");
		
		ctx.fillStyle = orangeGrad;
		ctx.fillRect(x - rad, y - rad, x + rad, y + rad);
		
		// add in stars to correct positions
		switch(stars)
		{
			case 1:
				drawStar(x, y, rad / 8);
				break;
				
			case 2:
				drawStar(x - rad/5, y - rad/5, rad/8);
				drawStar(x + rad/5, y + rad/5, rad/8)
				break;
				
			case 3:
				drawStar(x, y - rad/4, rad/8);
				drawStar(x - rad/4, y + rad/5, rad/8);
				drawStar(x + rad/4, y + rad/5, rad/8);
				break;
				
			case 4:
			default:
				drawStar(x - rad/2.5, y - rad/4, rad/8);
				drawStar(x + rad/5, y - rad/4, rad/8);
				drawStar(x - rad/4.5, y + rad/4, rad/8);
				drawStar(x + rad/2.5, y + rad/4, rad/8);
				break;
				
			case 5:
				drawStar(x, y - rad/2.5, rad/8);
				drawStar(x - rad/2.5, y - rad/8, rad/8);
				drawStar(x + rad/2.5, y - rad/8, rad/8);
				drawStar(x - rad/4, y + rad/3, rad/8);
				drawStar(x + rad/4, y + rad/3, rad/8);
				break;
				
			case 6:
				drawStar(x,y, rad/8);
				drawStar(x, y - rad/2.5, rad/8);
				drawStar(x - rad/2.5, y - rad/8, rad/8);
				drawStar(x + rad/2.5, y - rad/8, rad/8);
				drawStar(x - rad/4, y + rad/3, rad/8);
				drawStar(x + rad/4, y + rad/3, rad/8);
				break;
				
			case 7:
				drawStar(x,y, rad/8);
				drawStar(x - rad/2, y, rad/8);
				drawStar(x + rad/2, y, rad/8);
				drawStar(x - rad/4, y - rad/3, rad/8);
				drawStar(x + rad/4, y - rad/3, rad/8);
				drawStar(x - rad/4, y + rad/3, rad/8);
				drawStar(x + rad/4, y + rad/3, rad/8);
				break;
		}

		// add white circle in top left for shading
		let whiteGrad = ctx.createRadialGradient(x - rad/2, y - rad/2, 0, x - rad/4, y - rad/4, rad / 2);
		whiteGrad.addColorStop(0, "rgba(255, 255, 255, .5)");
		whiteGrad.addColorStop(0.8, "rgba(228, 228, 228, .3)");
		whiteGrad.addColorStop(1, "rgba(228, 228, 228, 0)");
		
		ctx.fillStyle = whiteGrad;
		ctx.fillRect(x - rad, y - rad, x + rad, y + rad);

		// restore ctx data
		ctx.restore();
	}
	
	// randy helper function
	function random(min, max, arr)
	{
		let num = Math.floor((Math.random() * max) + min);
	
		if (arr == null)
			return num;
		
		
		// if there is an array passed in, make sure there are no duplicate returns
		// https://stackoverflow.com/questions/27406377/javascript-generate-random-number-except-some-values?noredirect=1&lq=1
		
		let dupe = false; 										// set bool	to false
		for (let i = 0; i < arr.length; i++)
			if (num == arr[i])
				dupe = true;									// if num is equal to a value in the array, change it to true
				
		return (dupe == false) ? num : random(min, max, arr);	// if dupe is false, return num, otherwise, call random again
	}
	
	</script>
</head>
<body>
	<canvas width=700 height=600>Browser does not support canvas.</canvas>
	
	<br>
	
	<audio src="media/chala.mp3" id="audio"></audio>
	<label>Song:
			<select id="songSelector">
				<option value="chala" selected>Head Cha La</option>
				<option value="tank">Tank!</option>
				<option value="dmp">Digging My Potato</option>
				<option value="door">door</option>
			</select>
		</label>
		
	<img src="media/gokuIdle.png" id="play" />
	<label>Fighter:
			<select id="playSelector">
				<option value="goku" selected>Goku</option>
				<option value="vegeta">Vegeta</option>
				<option value="teenGohan">Teen Gohan</option>
				<option value="futureTrunks">Future Trunks</option>
				<option value="android18">Android 18</option>
				<option value="cell">Cell</option>
				<option value="majinbuu">Majin Buu</option>
				<option value="frieza">Frieza</option>
			</select>
	</label>

	<img src="media/friezaIdle.png" id="pause" />
	<label>Enemy:
			<select id="pauseSelector">
				<option value="goku">Goku</option>
				<option value="vegeta">Vegeta</option>
				<option value="teenGohan">Teen Gohan</option>
				<option value="futureTrunks">Future Trunks</option>
				<option value="android18">Android 18</option>
				<option value="cell">Cell</option>
				<option value="majinbuu">Majin Buu</option>
				<option value="frieza" selected>Frieza</option>
			</select>
	</label>
	
	
	<label for="ballRad">Ball Radius:</label>
	<input type="range" min="15" max="300" value="150" class="slider" id="ballRad">
	<span id="radiusLabel">???</span>

	<label for="volumeSlider">Volume:</label>
	<input type="range" id="volumeSlider" min="0" max="2" value="1" step="0.01">
	<span id="volumeLabel">???</span>

	<button id="addBall">Add Ball</button>
	<button id="remBall">Remove Ball</button>
	<button id="fullscreenBut">Full Screen</button>
	
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.0/js/bootstrap.min.js" integrity="sha384-7aThvCh9TypR7fIc2HV4O/nFMVCBwyIUKL8XCtKE+8xgCgl/PQGuFsvShjr74PBp" crossorigin="anonymous"></script>
</body>
</html>